@startuml
scale 0.5

package Data_types {
    enum Wildlife
    enum Biome
    enum Direction
    enum Rotation
    enum Variant

    struct Offset {
        + getCol() : int
        + getRow() : int
        + Offset(int c, int r)
        - col : int
        - row : int
    }
}

package GameActors {
    package Menus {

        abstract class Menu<T> {
            - T* m_results
            - int m_nb_result

            + Iterator getIterator() const
            + Menu()
            + ~Menu()
            + addResult(const T& tar) : void
            + {abstract} void show()
        }

        class Iterator<T> {
            - const Menu<T>& m_menu
            - int m_nb

            + Iterator(const Menu<T>& tar)
            + bool isDone() const
            + Iterator& operator++(int)
            + T getValue() const
        }

        Menu <|-- Iterator

        interface NotifiableInterface

        Menu <|-- NotifiableInterface
        Menu <|-- GMenu
        Menu <|-- CMenu

        package COMenus {
            abstract class CMenu {
                - unsigned int m_x_size
                + {abstract} void show()
                + void setX(unsigned int x)
                + unsigned int getX() const
            }
            class CGameMenu {
                + CGameMenu(NotifiableInterface* tar)
                + void show() override
            }
            class CPlayerMenu {
                - int m_result
                + CPlayerMenu()
                + void show() override
            }
            class CTokenMenu {
                - DeckTile* m_deck_tile
                - Player* const m_caller
                - unsigned short int m_nb_tokens
                + CTokenMenu(NotifiableInterface* tar, DeckTile* decktile, Player* caller)
                + ~CTokenMenu()
                + void show()
            }
            class CValidateMenu {
                + CValidateMenu(NotifiableInterface* tar)
                + ~CValidateMenu()
                + void show()
            }

            CMenu <|-- CGameMenu
            CMenu <|-- CPlayerMenu
            CMenu <|-- CTokenMenu
            CMenu <|-- CValidateMenu
        }

        package GXMenus {
            abstract class GMenu {
                - unsigned int m_size_x
                - unsigned int m_size_y
                - unsigned int m_pos_x
                - unsigned int m_pos_y
                # NotifiableInterface* m_target

                + GMenu(NotifiableInterface* target, QWidget* parent, unsigned int size_x, unsigned int size_y, unsigned int pos_x, unsigned int pos_y)
                + void actualize()
                + void show()
                + void setSizeX(unsigned int x)
                + void setSizeY(unsigned int y)
                + void setPosX(unsigned int x)
                + void setPosY(unsigned int y)
                + unsigned int getSizeX() const
                + unsigned int getSizeY() const
                + unsigned int getPosX() const
                + unsigned int getPosY() const
            }

            class GGameMenu {
                - QGridLayout* m_main_layout = nullptr
                - QLabel* m_label = nullptr
                - QLabel* m_label_exp_recover = nullptr
                - QLabel* m_label_exp_load_extension = nullptr
                - QLabel* m_label_exp_cards = nullptr

                - QPushButton* m_btn_recover = nullptr
                - QPushButton* m_btn_load_extension = nullptr
                - QPushButton* m_btn_validate = nullptr

                - QLineEdit* m_line_edit_cards = nullptr

                + GGameMenu(NotifiableInterface* tar)
                + void show()
                + void validate()
                + void usePreviousGame()
                + void loadExtension()
            }

            class GPlayerMenu {
                - QGridLayout* m_main_layout
                - QPushButton* m_btn_quit
                - QPushButton* m_btn_validate
                - QLabel* m_label
                - QSpinBox* m_spinbox
                - QLineEdit** m_lines_names
                - QLabel** m_label_names
                - unsigned short m_nb_player

                + GPlayerMenu(NotifiableInterface* tar)
                + ~GPlayerMenu()
                + void validateNumber()
                + void validateNames()
                + void show()
            }

            class GTokenMenu {
                - QGridLayout* m_main_layout
                - QPushButton* m_btn_validate
                - QPushButton* m_btn_clear_tokens
                - QPushButton* m_btn_no_token
                - QPushButton* m_btn_multichoice
                - QLabel* m_label
                - QLabel* m_label_token
                - QLabel* m_label_tile
                - QSpinBox* m_spin_tile
                - QSpinBox* m_spin_token
                - DeckTile* m_decktile
                - Player* m_caller

                + GTokenMenu(NotifiableInterface* tar, DeckTile* decktile, Player* caller)
                + ~GTokenMenu()
                + void selectTile()
                + void clearTokens()
                + void chooseMultiple()
                + void pushResults()
                + void show()
            }

            class GValidateMenu {
                - QLabel* m_label
                - QGridLayout* m_layout
                - QPushButton* m_btn_validate
                - QPushButton* m_btn_reject

                + GValidateMenu(NotifiableInterface* tar)
                + ~GValidateMenu()
                + void show() override
                + void validate()
                + void reject()
            }

            GMenu <|-- GGameMenu
            GMenu <|-- GPlayerMenu
            GMenu <|-- GTokenMenu
            GMenu <|-- GValidateMenu
        }
    }

    package GraphicalComponents {
        package Console {
            class CPlayerBoard {
                - const unsigned short m_max_height = 42
                - const unsigned short m_max_width = 140
                - unsigned short m_x_swift = 0
                - unsigned short m_y_swift = 0
                + CPlayerBoard()
                + void show()
            }
            class CDeckTile {
                - const unsigned short m_max_height
                - const unsigned short m_max_width
                + CDeckTile()
                + void show()
            }
        }

        package GraphX {
            class GDeckCard {
                + GDeckCard()
            }
            class GPlayerBoard {
                + GPlayerBoard()
            }
            class WidgetHexBoard {
                - int max_size
                - QVBoxLayout* m_layout
                + WidgetHexBoard(QWidget* parent = nullptr, int size = 41)
                + ~WidgetHexBoard() = default
                + void initHexTiles()
                + void addTile(int x, int y)
                <<signal>>
            }
            class GDeckTile {
                - GDeckTile(QObject* parent = nullptr)
                - void construct()
                - GDeckTile(const GDeckTile&) = delete
                - GDeckTile& operator=(const GDeckTile&) = delete
                - ~GDeckTile() = default
                - QVBoxLayout* tiles
                - QVBoxLayout* tokens
                - QHBoxLayout* deck
                - QWidget* widget
                - ClickableLabel* ti1
                - ClickableLabel* ti2
                - ClickableLabel* ti3
                - ClickableLabel* ti4
                - std::vector<ClickableLabel*> tilesL
                - ClickableLabel* to1
                - ClickableLabel* to2
                - ClickableLabel* to3
                - ClickableLabel* to4
                - std::vector<ClickableLabel*> tokenL

                + void update()
                + void show()
                + static GDeckTile& getInstance()
                --
                + signal tileClicked(int index)
                + signal tokenClicked(int index)
            }
            class ClickableLabel {
                + ClickableLabel(QWidget* parent = nullptr)
                --
                + signal clicked()
                # void mousePressEvent(QMouseEvent* event)
            }
            class GraphXView {
                + GraphXView(QGraphicsScene* scene, QWidget* parent = nullptr)
                --
                + signal rightClickAt(QPointF scenePos)
                # void mousePressEvent(QMouseEvent* event)
                # void wheelEvent(QWheelEvent* event)
            }
            class PixmapFactory {
                - PixmapFactory() = delete
                --
                + static QPixmap createTile(const GameTile* tile)
                + static QString matchToken(Wildlife wild)
                --
                - static QPixmap createIconWithOverlay(QString basePath, QString token1, int rot = 0, QString token2 = QString(), QString token3 = QString())
                - static QString matchTile(const GameTile* tile)
                - static QString matchToken(const GameTile* tile, int token)
            }

            GDeckTile --|> DeckTile
package Gametools {
    package Abstract {
        abstract BaseClass{
            + BaseClass()
            + ~BaseClass()
        }

    abstract class DeckTile {
        - m_deck_tiles : std::vector<GameTile*>
        - m_deck_token : std::vector<const WildlifeToken*>
        - m_tiles[4] : GameTile*
        - m_displayed_tokens[4] :  const WildlifeToken*
        - m_expected_card : vector<unsigned short int>
        - m_expected_token : vector<unsigned short int>
        - getInstance() : static DeckTile&
        - DeckTile();
        - {abstract} ~DeckTile()
        - m_id_token_to_rm : unsigned short int
        - m_can_flush : bool
        - m_id_card_to_rm : unsigned short int

        + getTile(unsigned short int i) : GameTile*
        + fillPlate() : int
        + canFlushWithoutNaturetoken() const : bool
        + addTile(GameTile* tile) : void
        + addToken(const WildlifeToken* token) : void
        + shuffle() : void
        + clearTokens() : void
        + validateChanges() : void
        + reinterpetString(def: const std::string&) : void
        + getSaveString() const : std::string
        + getCouple(id_card: int, id_token=-1) : tuple<GameTile*, const WildlifeToken*>
        + getCardsToAdd() : vector<unsigned short int>&
        + getTokensToAdd() : vector<unsigned short int>&
        + clear() : void

        # DeckTile()
        # ~DeckTile()
        # DeckTile(const DeckTile&) = delete
        # operator=(const DeckTile&) = delete
        + static getInstance() : DeckTile&
        }

        abstract NotifiableInterface {
            + NotifiableInterface()
            + {abstract} notify(unsigned int code) : void
        }

        abstract Printable {
            - bool m_is_graphic
            + {abstract} void print()
            + Printable()
        }

        abstract class SalvableThing {
            + SalvableThing();
            + {abstract} std::string getSaveString() const;
        }

        abstract class PlayerBoard {
            - m_pos_last_token : HexCell
            - m_pos_last_tile : HexCell

            - m_pointed_cell : HexCell
            - m_target : NotifiableInterface*

            + {static} int floorDiv(int n);
            + {static} axialToOffset(const HexCell& hex) : Offset
            + {static} offsetToAxial(const Offset& off) : HexCell
            + PlayerBoard()
            + show() : void
            + getSaveString() const : std::string
            + addTile(GameTile& tile) : void
            + addToken(const WildlifeToken* token, HexCell& pos_target) : void
            + removeLast() : void
            + hasNeighbour(const HexCell& pos) : bool
            + getPointedCell() const : HexCell
            + resetPointedCell() : void
            + setPointedCell(HexCell cell) : void
            + getTarget()const : NotifiableInterface*
            + getTile(int const &q, int const &r) const : GameTile*
            + pointCell(int q, int r) : void
        }

       abstract class TileHolder extends Printable, SalvableThing {
            - m_tiles : GameTile***
            - m_size_x : int
            - m_size_y : int

            + TileHolder(size_x : int, size_y : int)
            + ~TileHolder()
            + getTile(posx : int, posy : int) const : GameTile*
            + addTile(tile : GameTile&, x : int, y : int, overwrite : bool = false) : void
            + removeTile(x : int, y : int) : void
            + getFilledTilePositions() const : vector<pair<int, int>>
            + getFreeAdjacentCells(max_size : int) const : vector<HexCell>
            + getIterator() const : Iterator
            + show() = 0

            class Iterator {
                - m_holder : const TileHolder*
                - m_x : ushort
                - m_y : ushort

                + Iterator(tar : const TileHolder*)
                - Iterator(const Iterator&) = delete
                - operator=(const Iterator&) = delete
                + operator++(int) : Iterator&
                + getValue() const : const GameTile*
                + isDone() const : bool
        }

        BaseClass <|-- Printable
        BaseClass <|-- SalvableThing

        DeckTile <|-- CDeckTile
        DeckTile <|-- GDeckCard

        Printable <|-- GameTile
        Printable <|-- PlayerBoard

        SalvableThing <|-- Game
        SalvableThing <|-- GameTile
        SalvableThing <|-- PlayerBoard
        SalvableThing <|-- Player

        PlayerBoard <|-- TileHolder
        PlayerBoard <|-- CPlayerBoard
        PlayerBoard <|-- GPlayerBoard
        PlayerBoard o--  "1..1" Player
        PlayerBoard --> NotifiableInterface
        PlayerBoard --> GameTile
        PlayerBoard --> WildlifeToken
        PlayerBoard --> HexCell
        PlayerBoard --> Wildlife

        TileHolder <|-- DeckTile

        DeckTile ..|> Printable
        DeckTile ..|> SalvableThing
        Game --> DeckTile : friend
    }

    package Tiling {
        class GameTile {
            - Biome m_biomes[6]
            - Biome m_first_biome
            - unsigned char m_rotation
            - const WildlifeToken *m_wltoken
            - Wildlife *m_possible_wltoken
            - int m_numtypes
            - const unsigned int m_id

            - GameTile(std::string)
            - ~GameTile()
            - GameTile& operator=(const GameTile& oth)
            - GameTile(const GameTile& oth)

            + Rotate(Rotation dir) : void
            + draw() : int
            + getID() const : unsigned int

            + setPos(int const &q, int const &r) : void
            + getNbWildlife() const : int
            + getWildlife(unsigned short int nb) const : Wildlife
            + GameTile(unsigned int id, Biome biomes[6], Wildlife *type, int num_types, int posx, int posy)
            + getBiome(unsigned short int number) const : Biome
            + getId() const : unsigned int
            + getToken() const : const WildlifeToken*
            + setWildLifeToken(const WildlifeToken* wlt) : inline void
            + matchesType(Wildlife type) const : bool
            + matchesType(Biome biome) const : bool
            + isKeystone(const std::string& description) const : bool
            + show(unsigned short int size = 4) const : void
            + getFirstBiome() const : const Biome&
            + showCmd(unsigned short int = 4) const : void
            + std::string getSaveString() const
            + unsigned int getRotation() const
        }
        class HexCell {
            - int m_q
            - int m_r
            + {static} m_directions : const std::vector<HexCell>

            + {static} axialToOffset(const HexCell& hex, unsigned int size) : Offset
            + {static} offsetToAxial(const Offset& off, unsigned int size) : HexCell
            + {static} floorDiv(int n) : int
            + {static} directionTo(const HexCell& a, const HexCell& b) : HexCell

            + HexCell(int q, int r)
            + getQ() const : int
            + getR() const :int
            + getS() const : int

            + setQ(const int& q)
            + setR(const int& r)
            + HexCell operator+(const HexCell& other) const : HexCell
            + HexCell operator-(const HexCell& other) const : HexCell
            + operator==(const HexCell& other) const : bool
            + operator!=(const HexCell& other) const : bool
            + operator<(const HexCell& other) const : bool
            + operator+=(const HexCell& other) : HexCell
            + operator-=(const HexCell& other) : HexCell
            + rotate60() const : HexCell

            + getDirection(Direction d) const : HexCell
            + getNeighbors(Direction d) const : HexCell
            + getNeighbors() const : std::vector<HexCell>
        }

        GameTile ..> Wildlife
        GameTile ..> WildlifeToken
        GameTile --|> HexCell
        GameTile --|> SalvableThing

        HexCell <|-- GameTile
    }

    class WildlifeToken {
        - Wildlife m_type;
        - int m_xdprintpos
        - int m_ydprintpos
        + WildlifeToken(Wildlife type, int x_dpos, int y_dpos)
        + getWildlifeType() const : Wildlife

    }
}



package Scoring {
    class Score {
        - {static} m_animals: std::vector<std::string>
        - m_active_card: WildlifeScoringStrategy*
        - m_scoring_cards: std::vector<std::unique_ptr<WildlifeScoringStrategy>>

        + Score()
        + getScoringCards() const: const std::vector<std::unique_ptr<WildlifeScoringStrategy>>&
        + obtainScore(board: const PlayerBoard&) const: std::vector<double>
        + obtainScore(board: const PlayerBoard&, strat: const TileScoringStrategy&) const: std::vector<double>
        + setStrategy(idx_card: size_t): void
        + configureCards(cards: const std::string&): void
    }

    abstract class ScoringStrategy {
        + computeScore(board: const PlayerBoard&) const: std::vector<double>
        + ~ScoringStrategy() = default
    }
    package ScoreUtils {

      class UnionFind {
        - std::vector<int> parent
        - std::vector<int> rank
        + UnionFind(int n)
        + int find(int x)
        + void unite(int a, int b)
        + bool areConnected(int a, int b)
      }

      struct AdjacencyPolicy {
        + KeepTile shouldKeep
        + UniteTile shouldUnite
        + AdjacencyPolicy(KeepTile k, UniteTile u)
      }

      class Match {
        + int matchId
        + std::vector<GameTile*> tiles
      }

      ' typedefs / alias
      interface KeepTile <<functional>> {
        + bool operator()(GameTile*)
      }
      interface UniteTile <<functional>> {
        + bool operator()(GameTile*, GameTile*)
      }
      interface CompareFunction <<functional>> {
        + bool operator()(int, int)
      }

      ' Fonctions principales (signatures simplifi√©es)
      ' Pas de relations directes car fonctions libres dans le namespace
      class Functions {
        + std::unique_ptr<WildlifeScoringStrategy> makeWildlifeStrategy(const std::string&, char)
        + TileGrid gatherAllTiles(const PlayerBoard&, int size = MAX_SIZE)
        + TileGrid pruneTiles(const PlayerBoard&, std::vector<GameTile*>, std::function<bool(int,int)>, int threshold)
        + UnionFind buildUnionFind(const PlayerBoard&, int, const AdjacencyPolicy&, TileGrid&)
        + TileGrid buildBuckets(const TileGrid&, UnionFind)
        + TileGrid extractGroups(TileGrid)
        + TileGrid getComponents(const PlayerBoard&, int, const AdjacencyPolicy&)
        + AdjacencyPolicy makeBiomePolicy(const PlayerBoard&, Biome)
        + AdjacencyPolicy makeWildlifePolicy(Wildlife)
        + AdjacencyPolicy makeNeighborPolicy(const PlayerBoard&, Wildlife, int, CompareFunction)
        + AdjacencyPolicy makeSingletonPolicy(Wildlife)
        + AdjacencyPolicy combinePolicies(const AdjacencyPolicy&, const AdjacencyPolicy&)
        + std::vector<GameTile*> flatten(const std::vector<std::vector<GameTile*>>&)
        + GameTile* findTile(const std::vector<GameTile*>&, int q, int r)
        + void getLineFormations(const PlayerBoard&, int, Wildlife, TileGrid&, std::vector<int>&, const std::vector<int>&)
        + void getRingFormations(const PlayerBoard&, int, Wildlife, TileGrid&, std::vector<int>&, const std::vector<int>&)
        + void getShapeFormations(const PlayerBoard&, int, Wildlife, TileGrid&, std::vector<int>&, const std::vector<int>&)
        + void dfs(int idx, int curr_score, int& best_score, const std::vector<int>& points, const TileGrid& candidates, std::unordered_set<GameTile*>& used)
        + std::vector<std::pair<GameTile*, GameTile*>> getLinesOfSight(const PlayerBoard&, Wildlife)
        + std::vector<std::vector<HexCell>> getOrientations(const std::vector<HexCell>&)
        + std::vector<std::vector<HexCell>> getAllTemplates(const std::vector<std::vector<HexCell>>&)
        + int countUniqueTokensBetween(const PlayerBoard&, GameTile*, GameTile*, Wildlife)
      }

    }
    package ScoringStrategies {
        class TileScoringStrategy {
            + TileScoringStrategy()
            + computeScore(board: const PlayerBoard&) const: std::vector<double>
        }

        abstract WildlifeScoringStrategy {
            + ~WildlifeScoringStrategy() = default;
        }

        class VariantScoringStrategy {
            - variant: Variant
            + VariantScoringStrategy(v: Variant)
            + computeScore(board: const PlayerBoard&) const: std::vector<double>
            + getVariant() const: Variant
        }

    }
    package BearScoringCards {
        class BearScoringCardA {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class BearScoringCardB {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class BearScoringCardC {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class BearScoringCardD {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
    }
    package ElkScoringCards {
        class ElkScoringCardA {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class ElkScoringCardB {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class ElkScoringCardC {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class ElkScoringCardD {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
    }
    package FoxScoringCards {
        class FoxScoringCardA {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class FoxScoringCardB {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class FoxScoringCardC {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class FoxScoringCardD {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
    }
    package HawkScoringCards {
        class HawkScoringCardA {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class HawkScoringCardB {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class HawkScoringCardC {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class HawkScoringCardD {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
    }
    package SalmonScoringCards {
        class SalmonScoringCardA {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class SalmonScoringCardB {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class SalmonScoringCardC {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
        class SalmonScoringCardD {
            + std::vector<double> computeScore(const PlayerBoard& board) const
        }
    }


    ScoringStrategy <|-- TileScoringStrategy
    ScoringStrategy <|-- WildlifeScoringStrategy
    Score *-- ScoringStrategy

    WildlifeScoringStrategy --|> BearScoringCardA
    WildlifeScoringStrategy --|> BearScoringCardB
    WildlifeScoringStrategy --|> BearScoringCardC
    WildlifeScoringStrategy --|> BearScoringCardD

    WildlifeScoringStrategy --|> ElkScoringCardA
    WildlifeScoringStrategy --|> ElkScoringCardB
    WildlifeScoringStrategy --|> ElkScoringCardC
    WildlifeScoringStrategy --|> ElkScoringCardD

    WildlifeScoringStrategy --|> HawkScoringCardA
    WildlifeScoringStrategy --|> HawkScoringCardB
    WildlifeScoringStrategy --|> HawkScoringCardC
    WildlifeScoringStrategy --|> HawkScoringCardD

    WildlifeScoringStrategy --|> SalmonScoringCardA
    WildlifeScoringStrategy --|> SalmonScoringCardB
    WildlifeScoringStrategy --|> SalmonScoringCardC
    WildlifeScoringStrategy --|> SalmonScoringCardD

    WildlifeScoringStrategy --|> FoxScoringCardA
    WildlifeScoringStrategy --|> FoxScoringCardB
    WildlifeScoringStrategy --|> FoxScoringCardC
    WildlifeScoringStrategy --|> FoxScoringCardD


}

package Application {
    class QApplication {}

    class QWidget {}

    class App {
        + bool getIsConsole() const
        + {static} App& getInstance(int argc, char* argv[]);
        - App(const App& tar)
        - App& operator=(const App& tar)
        - bool m_is_console
        - App(int argc, char * argv[]
    }

    QApplication <|-- App
    QWidget <|-- GMenu
    QWidget <|-- WidgetHexBoard
    App *-- Game   
}


@enduml
